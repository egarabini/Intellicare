# üîß Especifica√ß√£o T√©cnica - Sistema de Gerenciamento de Emails

**Projeto:** IntelliCare Email Management System  
**Vers√£o:** 1.0  
**Data:** 2025-02-03

---

## 1. STACK TECNOL√ìGICA

### 1.1 Depend√™ncias Python

```txt
# requirements.txt
fastapi==0.115.0
uvicorn[standard]==0.32.0
celery[redis]==5.4.0
redis==5.2.0
jinja2==3.1.4
python-email-validator==2.2.0
pydantic==2.10.0
pydantic-settings==2.6.0
sqlalchemy==2.0.36
alembic==1.14.0
psycopg2-binary==2.9.10
python-multipart==0.0.18
aiosmtplib==3.0.2
httpx==0.28.1
flower==2.0.1
python-dotenv==1.0.1
```

### 1.2 Infraestrutura

- **Python:** 3.11+
- **Redis:** 7.0+ (broker + cache)
- **PostgreSQL:** 15+ (logs e auditoria)
- **Docker:** Para containeriza√ß√£o

---

## 2. ESTRUTURA DE DIRET√ìRIOS

```
INTELLICAREREPO/
‚îú‚îÄ‚îÄ email_service/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py                 # FastAPI app
‚îÇ   ‚îú‚îÄ‚îÄ celery_app.py           # Configura√ß√£o Celery
‚îÇ   ‚îú‚îÄ‚îÄ config.py               # Settings (Pydantic)
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email_log.py        # SQLAlchemy models
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schemas.py          # Pydantic schemas
‚îÇ   ‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ email_tasks.py      # Celery tasks
‚îÇ   ‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py             # Abstract provider
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ smtp_provider.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mailgun_provider.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sendgrid_provider.py
‚îÇ   ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.html           # Template base
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verification.html
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status_update.html
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ welcome.html
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ password_reset.html
‚îÇ   ‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ emails.py           # API endpoints
‚îÇ   ‚îú‚îÄ‚îÄ database.py             # SQLAlchemy setup
‚îÇ   ‚îî‚îÄ‚îÄ utils.py                # Helpers
‚îú‚îÄ‚îÄ alembic/                    # Migrations
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ .env.example
‚îî‚îÄ‚îÄ requirements.txt
```

---

## 3. CONFIGURA√á√ÉO (config.py)

```python
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Literal

class Settings(BaseSettings):
    """Configura√ß√µes do sistema de email"""
    
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False
    )
    
    # FastAPI
    app_name: str = "IntelliCare Email Service"
    app_version: str = "1.0.0"
    debug: bool = False
    
    # Database
    database_url: str = "postgresql://user:pass@localhost:5432/intellicare_emails"
    
    # Redis
    redis_url: str = "redis://localhost:6379/0"
    
    # Celery
    celery_broker_url: str = "redis://localhost:6379/0"
    celery_result_backend: str = "redis://localhost:6379/1"
    celery_task_track_started: bool = True
    celery_task_time_limit: int = 30  # segundos
    
    # Email Provider
    email_provider: Literal["smtp", "mailgun", "sendgrid"] = "smtp"
    email_fallback_provider: Literal["smtp", "mailgun", "sendgrid", "none"] = "none"
    
    # SMTP
    smtp_host: str = "smtp.gmail.com"
    smtp_port: int = 587
    smtp_username: str = ""
    smtp_password: str = ""
    smtp_use_tls: bool = True
    smtp_from_email: str = "noreply@intellicare.com.br"
    smtp_from_name: str = "IntelliCare"
    
    # Mailgun
    mailgun_api_key: str = ""
    mailgun_domain: str = ""
    mailgun_from_email: str = "noreply@intellicare.com.br"
    
    # SendGrid
    sendgrid_api_key: str = ""
    sendgrid_from_email: str = "noreply@intellicare.com.br"
    
    # Rate Limiting
    rate_limit_per_minute: int = 100
    
    # Retry Policy
    max_retries: int = 3
    retry_backoff: int = 60  # segundos
    
    # Templates
    templates_dir: str = "email_service/templates"
    
    # Logs
    log_retention_days: int = 90

settings = Settings()
```

---

## 4. MODELOS DE DADOS (models/email_log.py)

```python
from sqlalchemy import Column, String, DateTime, Integer, Text, JSON, Enum
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime
import enum

Base = declarative_base()

class EmailStatus(str, enum.Enum):
    PENDING = "pending"
    SENT = "sent"
    DELIVERED = "delivered"
    FAILED = "failed"
    BOUNCED = "bounced"
    OPENED = "opened"
    CLICKED = "clicked"

class EmailPriority(str, enum.Enum):
    URGENT = "urgent"
    NORMAL = "normal"
    LOW = "low"

class EmailLog(Base):
    __tablename__ = "email_logs"
    
    id = Column(String(36), primary_key=True)  # UUID
    task_id = Column(String(255), index=True, nullable=True)
    
    # Destinat√°rio
    to_email = Column(String(255), nullable=False, index=True)
    to_name = Column(String(255), nullable=True)
    
    # Conte√∫do
    subject = Column(String(500), nullable=False)
    template_name = Column(String(100), nullable=True)
    template_vars = Column(JSON, nullable=True)
    html_body = Column(Text, nullable=True)
    text_body = Column(Text, nullable=True)
    
    # Metadados
    priority = Column(Enum(EmailPriority), default=EmailPriority.NORMAL)
    status = Column(Enum(EmailStatus), default=EmailStatus.PENDING, index=True)
    provider = Column(String(50), nullable=True)
    
    # Tentativas
    attempts = Column(Integer, default=0)
    max_attempts = Column(Integer, default=3)
    last_error = Column(Text, nullable=True)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    sent_at = Column(DateTime, nullable=True)
    delivered_at = Column(DateTime, nullable=True)
    opened_at = Column(DateTime, nullable=True)
    clicked_at = Column(DateTime, nullable=True)
    failed_at = Column(DateTime, nullable=True)
    
    # Anexos (JSON array de URLs)
    attachments = Column(JSON, nullable=True)
    
    # Contexto adicional
    metadata = Column(JSON, nullable=True)
```

---

## 5. SCHEMAS PYDANTIC (models/schemas.py)

```python
from pydantic import BaseModel, EmailStr, Field
from typing import Optional, Dict, Any, List
from datetime import datetime
from enum import Enum

class EmailPriority(str, Enum):
    URGENT = "urgent"
    NORMAL = "normal"
    LOW = "low"

class SendEmailRequest(BaseModel):
    to_email: EmailStr
    to_name: Optional[str] = None
    subject: str = Field(..., min_length=1, max_length=500)
    template_name: Optional[str] = None
    template_vars: Optional[Dict[str, Any]] = None
    html_body: Optional[str] = None
    text_body: Optional[str] = None
    priority: EmailPriority = EmailPriority.NORMAL
    attachments: Optional[List[str]] = None
    metadata: Optional[Dict[str, Any]] = None
    
    class Config:
        json_schema_extra = {
            "example": {
                "to_email": "usuario@example.com",
                "to_name": "Jo√£o Silva",
                "subject": "Verifica√ß√£o de Email",
                "template_name": "verification",
                "template_vars": {
                    "token": "12345",
                    "protocol": "INTC-2025-001"
                },
                "priority": "urgent"
            }
        }

class SendEmailResponse(BaseModel):
    success: bool
    task_id: str
    email_id: str
    message: str

class EmailStatusResponse(BaseModel):
    email_id: str
    status: str
    to_email: str
    subject: str
    created_at: datetime
    sent_at: Optional[datetime]
    delivered_at: Optional[datetime]
    attempts: int
    last_error: Optional[str]
```

---

## 6. CELERY CONFIGURATION (celery_app.py)

```python
from celery import Celery
from .config import settings

# Criar app Celery
celery_app = Celery(
    "intellicare_emails",
    broker=settings.celery_broker_url,
    backend=settings.celery_result_backend,
)

# Configura√ß√£o
celery_app.conf.update(
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="America/Sao_Paulo",
    enable_utc=True,
    task_track_started=True,
    task_time_limit=settings.celery_task_time_limit,
    task_soft_time_limit=settings.celery_task_time_limit - 5,
    worker_prefetch_multiplier=4,
    worker_max_tasks_per_child=1000,
    task_acks_late=True,
    task_reject_on_worker_lost=True,

    # Filas por prioridade
    task_routes={
        "email_service.tasks.email_tasks.send_email_task": {
            "queue": "emails",
        },
    },

    # Retry policy
    task_autoretry_for=(Exception,),
    task_retry_kwargs={"max_retries": settings.max_retries},
    task_retry_backoff=settings.retry_backoff,
    task_retry_backoff_max=600,  # 10 minutos
    task_retry_jitter=True,
)

# Auto-discover tasks
celery_app.autodiscover_tasks(["email_service.tasks"])
```

---

## 7. PROVIDER BASE (providers/base.py)

```python
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any

class EmailProvider(ABC):
    """Interface abstrata para provedores de email"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config

    @abstractmethod
    async def send(
        self,
        to_email: str,
        subject: str,
        html_body: str,
        text_body: Optional[str] = None,
        from_email: Optional[str] = None,
        from_name: Optional[str] = None,
        attachments: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """
        Envia um email

        Returns:
            Dict com:
                - success: bool
                - message_id: str (ID do provedor)
                - error: Optional[str]
        """
        pass

    @abstractmethod
    def get_name(self) -> str:
        """Retorna nome do provedor"""
        pass
```

---

## 8. SMTP PROVIDER (providers/smtp_provider.py)

```python
import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from typing import Optional, List, Dict, Any
import logging

from .base import EmailProvider

logger = logging.getLogger(__name__)

class SMTPProvider(EmailProvider):
    """Provedor SMTP (Gmail, Outlook, etc.)"""

    def get_name(self) -> str:
        return "SMTP"

    async def send(
        self,
        to_email: str,
        subject: str,
        html_body: str,
        text_body: Optional[str] = None,
        from_email: Optional[str] = None,
        from_name: Optional[str] = None,
        attachments: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        try:
            # Criar mensagem
            message = MIMEMultipart("alternative")
            message["Subject"] = subject
            message["From"] = f"{from_name or self.config['from_name']} <{from_email or self.config['from_email']}>"
            message["To"] = to_email

            # Adicionar corpo texto plano
            if text_body:
                part1 = MIMEText(text_body, "plain", "utf-8")
                message.attach(part1)

            # Adicionar corpo HTML
            part2 = MIMEText(html_body, "html", "utf-8")
            message.attach(part2)

            # TODO: Adicionar anexos (se necess√°rio)

            # Enviar via SMTP
            await aiosmtplib.send(
                message,
                hostname=self.config["host"],
                port=self.config["port"],
                username=self.config["username"],
                password=self.config["password"],
                use_tls=self.config["use_tls"],
                timeout=30,
            )

            logger.info(f"Email enviado via SMTP para {to_email}")

            return {
                "success": True,
                "message_id": message["Message-ID"],
                "error": None,
            }

        except Exception as e:
            logger.error(f"Erro ao enviar email via SMTP: {str(e)}")
            return {
                "success": False,
                "message_id": None,
                "error": str(e),
            }
```

---

## 9. MAILGUN PROVIDER (providers/mailgun_provider.py)

```python
import httpx
from typing import Optional, List, Dict, Any
import logging

from .base import EmailProvider

logger = logging.getLogger(__name__)

class MailgunProvider(EmailProvider):
    """Provedor Mailgun (API)"""

    def get_name(self) -> str:
        return "Mailgun"

    async def send(
        self,
        to_email: str,
        subject: str,
        html_body: str,
        text_body: Optional[str] = None,
        from_email: Optional[str] = None,
        from_name: Optional[str] = None,
        attachments: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        try:
            url = f"https://api.mailgun.net/v3/{self.config['domain']}/messages"

            data = {
                "from": f"{from_name or 'IntelliCare'} <{from_email or self.config['from_email']}>",
                "to": to_email,
                "subject": subject,
                "html": html_body,
            }

            if text_body:
                data["text"] = text_body

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    url,
                    auth=("api", self.config["api_key"]),
                    data=data,
                    timeout=30,
                )

                if response.status_code == 200:
                    result = response.json()
                    logger.info(f"Email enviado via Mailgun para {to_email}")
                    return {
                        "success": True,
                        "message_id": result.get("id"),
                        "error": None,
                    }
                else:
                    error_msg = f"Mailgun error {response.status_code}: {response.text}"
                    logger.error(error_msg)
                    return {
                        "success": False,
                        "message_id": None,
                        "error": error_msg,
                    }

        except Exception as e:
            logger.error(f"Erro ao enviar email via Mailgun: {str(e)}")
            return {
                "success": False,
                "message_id": None,
                "error": str(e),
            }
```

---

## 10. SENDGRID PROVIDER (providers/sendgrid_provider.py)

```python
import httpx
from typing import Optional, List, Dict, Any
import logging

from .base import EmailProvider

logger = logging.getLogger(__name__)

class SendGridProvider(EmailProvider):
    """Provedor SendGrid (API)"""

    def get_name(self) -> str:
        return "SendGrid"

    async def send(
        self,
        to_email: str,
        subject: str,
        html_body: str,
        text_body: Optional[str] = None,
        from_email: Optional[str] = None,
        from_name: Optional[str] = None,
        attachments: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        try:
            url = "https://api.sendgrid.com/v3/mail/send"

            payload = {
                "personalizations": [
                    {
                        "to": [{"email": to_email}],
                        "subject": subject,
                    }
                ],
                "from": {
                    "email": from_email or self.config["from_email"],
                    "name": from_name or "IntelliCare",
                },
                "content": [
                    {"type": "text/html", "value": html_body}
                ],
            }

            if text_body:
                payload["content"].insert(0, {"type": "text/plain", "value": text_body})

            headers = {
                "Authorization": f"Bearer {self.config['api_key']}",
                "Content-Type": "application/json",
            }

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    url,
                    json=payload,
                    headers=headers,
                    timeout=30,
                )

                if response.status_code == 202:
                    logger.info(f"Email enviado via SendGrid para {to_email}")
                    return {
                        "success": True,
                        "message_id": response.headers.get("X-Message-Id"),
                        "error": None,
                    }
                else:
                    error_msg = f"SendGrid error {response.status_code}: {response.text}"
                    logger.error(error_msg)
                    return {
                        "success": False,
                        "message_id": None,
                        "error": error_msg,
                    }

        except Exception as e:
            logger.error(f"Erro ao enviar email via SendGrid: {str(e)}")
            return {
                "success": False,
                "message_id": None,
                "error": str(e),
            }
```

---

## 11. EMAIL TASKS (tasks/email_tasks.py)

```python
from celery import Task
from sqlalchemy.orm import Session
from datetime import datetime
from jinja2 import Environment, FileSystemLoader
import uuid
import logging

from ..celery_app import celery_app
from ..config import settings
from ..database import SessionLocal
from ..models.email_log import EmailLog, EmailStatus
from ..providers.smtp_provider import SMTPProvider
from ..providers.mailgun_provider import MailgunProvider
from ..providers.sendgrid_provider import SendGridProvider

logger = logging.getLogger(__name__)

# Configurar Jinja2
jinja_env = Environment(loader=FileSystemLoader(settings.templates_dir))

def get_provider(provider_name: str):
    """Factory para criar provider"""
    if provider_name == "smtp":
        return SMTPProvider({
            "host": settings.smtp_host,
            "port": settings.smtp_port,
            "username": settings.smtp_username,
            "password": settings.smtp_password,
            "use_tls": settings.smtp_use_tls,
            "from_email": settings.smtp_from_email,
            "from_name": settings.smtp_from_name,
        })
    elif provider_name == "mailgun":
        return MailgunProvider({
            "api_key": settings.mailgun_api_key,
            "domain": settings.mailgun_domain,
            "from_email": settings.mailgun_from_email,
        })
    elif provider_name == "sendgrid":
        return SendGridProvider({
            "api_key": settings.sendgrid_api_key,
            "from_email": settings.sendgrid_from_email,
        })
    else:
        raise ValueError(f"Provider desconhecido: {provider_name}")

@celery_app.task(
    bind=True,
    name="email_service.tasks.email_tasks.send_email_task",
    max_retries=3,
    default_retry_delay=60,
)
async def send_email_task(
    self: Task,
    email_id: str,
    to_email: str,
    subject: str,
    html_body: str = None,
    text_body: str = None,
    template_name: str = None,
    template_vars: dict = None,
    priority: str = "normal",
    to_name: str = None,
):
    """
    Tarefa Celery para enviar email
    """
    db: Session = SessionLocal()

    try:
        # Buscar log do email
        email_log = db.query(EmailLog).filter(EmailLog.id == email_id).first()

        if not email_log:
            logger.error(f"Email log n√£o encontrado: {email_id}")
            return

        # Atualizar task_id
        email_log.task_id = self.request.id
        email_log.attempts += 1
        db.commit()

        # Renderizar template se necess√°rio
        if template_name and template_vars:
            try:
                template = jinja_env.get_template(f"{template_name}.html")
                html_body = template.render(**template_vars)
            except Exception as e:
                logger.error(f"Erro ao renderizar template {template_name}: {str(e)}")
                email_log.status = EmailStatus.FAILED
                email_log.last_error = f"Template error: {str(e)}"
                email_log.failed_at = datetime.utcnow()
                db.commit()
                return

        # Obter provider
        provider = get_provider(settings.email_provider)
        email_log.provider = provider.get_name()
        db.commit()

        # Enviar email
        result = await provider.send(
            to_email=to_email,
            subject=subject,
            html_body=html_body,
            text_body=text_body,
            from_email=None,  # Usa padr√£o do provider
            from_name=None,
            attachments=None,
        )

        if result["success"]:
            # Sucesso
            email_log.status = EmailStatus.SENT
            email_log.sent_at = datetime.utcnow()
            email_log.last_error = None
            logger.info(f"‚úÖ Email {email_id} enviado com sucesso para {to_email}")
        else:
            # Falha - tentar fallback
            if settings.email_fallback_provider != "none":
                logger.warning(f"Tentando fallback provider: {settings.email_fallback_provider}")
                fallback_provider = get_provider(settings.email_fallback_provider)
                result = await fallback_provider.send(
                    to_email=to_email,
                    subject=subject,
                    html_body=html_body,
                    text_body=text_body,
                )

                if result["success"]:
                    email_log.status = EmailStatus.SENT
                    email_log.sent_at = datetime.utcnow()
                    email_log.provider = fallback_provider.get_name()
                    logger.info(f"‚úÖ Email {email_id} enviado via fallback")
                else:
                    raise Exception(result["error"])
            else:
                raise Exception(result["error"])

        db.commit()

    except Exception as exc:
        logger.error(f"‚ùå Erro ao enviar email {email_id}: {str(exc)}")

        email_log.last_error = str(exc)

        if email_log.attempts >= settings.max_retries:
            email_log.status = EmailStatus.FAILED
            email_log.failed_at = datetime.utcnow()
            logger.error(f"Email {email_id} falhou ap√≥s {email_log.attempts} tentativas")

        db.commit()

        # Retry se n√£o atingiu limite
        if email_log.attempts < settings.max_retries:
            raise self.retry(exc=exc, countdown=settings.retry_backoff * email_log.attempts)

    finally:
        db.close()
```

---

## 12. DATABASE SETUP (database.py)

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from .config import settings

# Engine
engine = create_engine(
    settings.database_url,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
)

# Session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    """Dependency para FastAPI"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

---

## 13. API ENDPOINTS (routers/emails.py)

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime
import uuid

from ..database import get_db
from ..models.email_log import EmailLog, EmailStatus, EmailPriority
from ..models.schemas import SendEmailRequest, SendEmailResponse, EmailStatusResponse
from ..tasks.email_tasks import send_email_task

router = APIRouter(prefix="/api/emails", tags=["Emails"])

@router.post("/send", response_model=SendEmailResponse, status_code=status.HTTP_202_ACCEPTED)
async def send_email(
    request: SendEmailRequest,
    db: Session = Depends(get_db),
):
    """
    Envia um email de forma ass√≠ncrona

    - **to_email**: Email do destinat√°rio
    - **subject**: Assunto do email
    - **template_name**: Nome do template (opcional)
    - **template_vars**: Vari√°veis do template (opcional)
    - **html_body**: Corpo HTML (se n√£o usar template)
    - **priority**: urgent, normal, low
    """
    try:
        # Gerar ID √∫nico
        email_id = str(uuid.uuid4())

        # Criar log no banco
        email_log = EmailLog(
            id=email_id,
            to_email=request.to_email,
            to_name=request.to_name,
            subject=request.subject,
            template_name=request.template_name,
            template_vars=request.template_vars,
            html_body=request.html_body,
            text_body=request.text_body,
            priority=EmailPriority(request.priority),
            status=EmailStatus.PENDING,
            attachments=request.attachments,
            metadata=request.metadata,
        )

        db.add(email_log)
        db.commit()
        db.refresh(email_log)

        # Enviar para fila Celery
        task = send_email_task.apply_async(
            kwargs={
                "email_id": email_id,
                "to_email": request.to_email,
                "to_name": request.to_name,
                "subject": request.subject,
                "html_body": request.html_body,
                "text_body": request.text_body,
                "template_name": request.template_name,
                "template_vars": request.template_vars,
                "priority": request.priority,
            },
            queue=f"emails_{request.priority}",  # Fila por prioridade
            priority={"urgent": 9, "normal": 5, "low": 1}[request.priority],
        )

        return SendEmailResponse(
            success=True,
            task_id=task.id,
            email_id=email_id,
            message=f"Email agendado para envio (prioridade: {request.priority})",
        )

    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erro ao agendar email: {str(e)}",
        )

@router.get("/status/{email_id}", response_model=EmailStatusResponse)
async def get_email_status(
    email_id: str,
    db: Session = Depends(get_db),
):
    """
    Consulta o status de um email
    """
    email_log = db.query(EmailLog).filter(EmailLog.id == email_id).first()

    if not email_log:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Email n√£o encontrado",
        )

    return EmailStatusResponse(
        email_id=email_log.id,
        status=email_log.status.value,
        to_email=email_log.to_email,
        subject=email_log.subject,
        created_at=email_log.created_at,
        sent_at=email_log.sent_at,
        delivered_at=email_log.delivered_at,
        attempts=email_log.attempts,
        last_error=email_log.last_error,
    )

@router.get("/stats")
async def get_email_stats(db: Session = Depends(get_db)):
    """
    Estat√≠sticas de emails
    """
    from sqlalchemy import func

    total = db.query(func.count(EmailLog.id)).scalar()
    sent = db.query(func.count(EmailLog.id)).filter(EmailLog.status == EmailStatus.SENT).scalar()
    failed = db.query(func.count(EmailLog.id)).filter(EmailLog.status == EmailStatus.FAILED).scalar()
    pending = db.query(func.count(EmailLog.id)).filter(EmailLog.status == EmailStatus.PENDING).scalar()

    return {
        "total": total,
        "sent": sent,
        "failed": failed,
        "pending": pending,
        "success_rate": round((sent / total * 100) if total > 0 else 0, 2),
    }
```

---

## 14. FASTAPI MAIN APP (main.py)

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import logging

from .config import settings
from .routers import emails
from .database import engine
from .models.email_log import Base

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)

# Criar tabelas
Base.metadata.create_all(bind=engine)

# App FastAPI
app = FastAPI(
    title=settings.app_name,
    version=settings.app_version,
    description="Sistema profissional de gerenciamento de emails com filas ass√≠ncronas",
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Ajustar em produ√ß√£o
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Routers
app.include_router(emails.router)

@app.get("/")
async def root():
    return {
        "service": settings.app_name,
        "version": settings.app_version,
        "status": "running",
    }

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

---

## 15. DOCKER CONFIGURATION

### 15.1 Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Instalar depend√™ncias do sistema
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Copiar requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copiar c√≥digo
COPY email_service/ ./email_service/

# Expor porta
EXPOSE 8000

# Comando padr√£o (FastAPI)
CMD ["uvicorn", "email_service.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 15.2 docker-compose.yml

```yaml
version: '3.8'

services:
  # PostgreSQL
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: intellicare_emails
      POSTGRES_USER: intellicare
      POSTGRES_PASSWORD: intellicare_pass_2025
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U intellicare"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # FastAPI App
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://intellicare:intellicare_pass_2025@postgres:5432/intellicare_emails
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/1
    env_file:
      - .env
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: uvicorn email_service.main:app --host 0.0.0.0 --port 8000 --reload

  # Celery Worker
  celery_worker:
    build: .
    environment:
      - DATABASE_URL=postgresql://intellicare:intellicare_pass_2025@postgres:5432/intellicare_emails
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/1
    env_file:
      - .env
    depends_on:
      - postgres
      - redis
    command: celery -A email_service.celery_app worker --loglevel=info --concurrency=4 -Q emails_urgent,emails_normal,emails_low

  # Flower (Monitoring)
  flower:
    build: .
    ports:
      - "5555:5555"
    environment:
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/1
    depends_on:
      - redis
      - celery_worker
    command: celery -A email_service.celery_app flower --port=5555

volumes:
  postgres_data:
  redis_data:
```

---

## 16. TEMPLATE EXAMPLE (templates/verification.html)

```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verifica√ß√£o de Email - IntelliCare</title>
</head>
<body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f3f4f6;">
    <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f3f4f6; padding: 20px;">
        <tr>
            <td align="center">
                <table width="600" cellpadding="0" cellspacing="0" style="background-color: #ffffff; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Header -->
                    <tr>
                        <td style="background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%); padding: 30px; text-align: center;">
                            <h1 style="color: #ffffff; margin: 0; font-size: 28px;">IntelliCare</h1>
                            <p style="color: #e0e7ff; margin: 5px 0 0 0; font-size: 14px;">Portal de Agentes Inteligentes em Sa√∫de</p>
                        </td>
                    </tr>

                    <!-- Body -->
                    <tr>
                        <td style="padding: 40px 30px;">
                            <h2 style="color: #1f2937; margin: 0 0 20px 0; font-size: 24px;">Verifica√ß√£o de Email</h2>

                            <p style="color: #4b5563; font-size: 16px; line-height: 1.6; margin: 0 0 20px 0;">
                                Ol√°,
                            </p>

                            <p style="color: #4b5563; font-size: 16px; line-height: 1.6; margin: 0 0 30px 0;">
                                Recebemos sua solicita√ß√£o no IntelliCare. Para confirmar seu email e prosseguir, utilize o c√≥digo abaixo:
                            </p>

                            <!-- Token Box -->
                            <table width="100%" cellpadding="0" cellspacing="0">
                                <tr>
                                    <td style="background-color: #f3f4f6; padding: 30px; text-align: center; border-radius: 8px;">
                                        <div style="font-size: 42px; font-weight: bold; letter-spacing: 12px; color: #1f2937; font-family: 'Courier New', monospace;">
                                            {{ token }}
                                        </div>
                                    </td>
                                </tr>
                            </table>

                            <p style="color: #6b7280; font-size: 14px; margin: 20px 0 10px 0;">
                                ‚è±Ô∏è Este c√≥digo expira em <strong>30 minutos</strong>.
                            </p>

                            <p style="color: #6b7280; font-size: 14px; margin: 0;">
                                üìã Protocolo: <strong style="color: #2563eb;">{{ protocol }}</strong>
                            </p>
                        </td>
                    </tr>

                    <!-- Footer -->
                    <tr>
                        <td style="background-color: #f9fafb; padding: 20px 30px; border-top: 1px solid #e5e7eb;">
                            <p style="color: #9ca3af; font-size: 12px; line-height: 1.6; margin: 0;">
                                Se voc√™ n√£o solicitou isso, ignore este email.<br>
                                Este √© um email autom√°tico, por favor n√£o responda.
                            </p>
                            <p style="color: #9ca3af; font-size: 12px; margin: 15px 0 0 0;">
                                ¬© 2025 IntelliCare - Todos os direitos reservados
                            </p>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</body>
</html>
```

---

## 17. ENVIRONMENT VARIABLES (.env.example)

```bash
# FastAPI
APP_NAME=IntelliCare Email Service
APP_VERSION=1.0.0
DEBUG=false

# Database
DATABASE_URL=postgresql://intellicare:intellicare_pass_2025@localhost:5432/intellicare_emails

# Redis
REDIS_URL=redis://localhost:6379/0
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/1

# Email Provider (smtp, mailgun, sendgrid)
EMAIL_PROVIDER=smtp
EMAIL_FALLBACK_PROVIDER=none

# SMTP Configuration
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your-email@gmail.com
SMTP_PASSWORD=your-app-password
SMTP_USE_TLS=true
SMTP_FROM_EMAIL=noreply@intellicare.com.br
SMTP_FROM_NAME=IntelliCare

# Mailgun (opcional)
MAILGUN_API_KEY=your-mailgun-api-key
MAILGUN_DOMAIN=mg.intellicare.com.br
MAILGUN_FROM_EMAIL=noreply@intellicare.com.br

# SendGrid (opcional)
SENDGRID_API_KEY=your-sendgrid-api-key
SENDGRID_FROM_EMAIL=noreply@intellicare.com.br

# Retry Policy
MAX_RETRIES=3
RETRY_BACKOFF=60

# Rate Limiting
RATE_LIMIT_PER_MINUTE=100

# Templates
TEMPLATES_DIR=email_service/templates

# Logs
LOG_RETENTION_DAYS=90
```

---

## 18. DEPLOYMENT GUIDE

### 18.1 Instala√ß√£o Local

```bash
# 1. Clonar reposit√≥rio
cd INTELLICAREREPO

# 2. Criar ambiente virtual
python -m venv venv
source venv/bin/activate  # Linux/Mac
# ou
.\venv\Scripts\activate  # Windows

# 3. Instalar depend√™ncias
pip install -r requirements.txt

# 4. Configurar vari√°veis de ambiente
cp .env.example .env
# Editar .env com suas credenciais

# 5. Iniciar servi√ßos (Docker)
docker-compose up -d postgres redis

# 6. Criar tabelas do banco
python -c "from email_service.database import engine; from email_service.models.email_log import Base; Base.metadata.create_all(bind=engine)"

# 7. Iniciar FastAPI
uvicorn email_service.main:app --reload --port 8000

# 8. Iniciar Celery Worker (novo terminal)
celery -A email_service.celery_app worker --loglevel=info -Q emails_urgent,emails_normal,emails_low

# 9. Iniciar Flower (novo terminal)
celery -A email_service.celery_app flower --port=5555
```

### 18.2 Deployment com Docker

```bash
# Build e start de todos os servi√ßos
docker-compose up -d

# Verificar logs
docker-compose logs -f api
docker-compose logs -f celery_worker

# Acessar servi√ßos:
# - API: http://localhost:8000
# - Docs: http://localhost:8000/docs
# - Flower: http://localhost:5555
```

### 18.3 Produ√ß√£o (Kubernetes - exemplo)

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: email-service-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: email-service-api
  template:
    metadata:
      labels:
        app: email-service-api
    spec:
      containers:
      - name: api
        image: intellicare/email-service:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: email-service-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: email-service-worker
spec:
  replicas: 5
  selector:
    matchLabels:
      app: email-service-worker
  template:
    metadata:
      labels:
        app: email-service-worker
    spec:
      containers:
      - name: worker
        image: intellicare/email-service:latest
        command: ["celery", "-A", "email_service.celery_app", "worker", "--loglevel=info", "-Q", "emails_urgent,emails_normal,emails_low"]
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
```

---

## 19. TESTING

### 19.1 Teste Unit√°rio (tests/test_providers.py)

```python
import pytest
from email_service.providers.smtp_provider import SMTPProvider

@pytest.mark.asyncio
async def test_smtp_provider_send():
    """Testa envio via SMTP"""
    provider = SMTPProvider({
        "host": "smtp.gmail.com",
        "port": 587,
        "username": "test@gmail.com",
        "password": "test-password",
        "use_tls": True,
        "from_email": "noreply@test.com",
        "from_name": "Test",
    })

    result = await provider.send(
        to_email="recipient@example.com",
        subject="Test Email",
        html_body="<h1>Test</h1>",
        text_body="Test",
    )

    assert result["success"] == True
    assert result["message_id"] is not None
```

### 19.2 Teste de Integra√ß√£o

```python
import pytest
from fastapi.testclient import TestClient
from email_service.main import app

client = TestClient(app)

def test_send_email_endpoint():
    """Testa endpoint de envio"""
    response = client.post(
        "/api/emails/send",
        json={
            "to_email": "test@example.com",
            "subject": "Test Subject",
            "template_name": "verification",
            "template_vars": {
                "token": "12345",
                "protocol": "TEST-001"
            },
            "priority": "urgent"
        }
    )

    assert response.status_code == 202
    data = response.json()
    assert data["success"] == True
    assert "task_id" in data
    assert "email_id" in data

def test_get_email_status():
    """Testa consulta de status"""
    # Primeiro envia um email
    send_response = client.post("/api/emails/send", json={...})
    email_id = send_response.json()["email_id"]

    # Consulta status
    status_response = client.get(f"/api/emails/status/{email_id}")
    assert status_response.status_code == 200
    data = status_response.json()
    assert data["email_id"] == email_id
    assert "status" in data
```

---

## 20. USAGE EXAMPLES

### 20.1 Python Client

```python
import httpx
import asyncio

async def send_verification_email(email: str, token: str, protocol: str):
    """Envia email de verifica√ß√£o"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "http://localhost:8000/api/emails/send",
            json={
                "to_email": email,
                "subject": "IntelliCare - Verifica√ß√£o de Email",
                "template_name": "verification",
                "template_vars": {
                    "token": token,
                    "protocol": protocol
                },
                "priority": "urgent"
            }
        )
        return response.json()

# Uso
result = asyncio.run(send_verification_email(
    email="usuario@example.com",
    token="12345",
    protocol="INTC-2025-001"
))
print(f"Email agendado: {result['email_id']}")
```

### 20.2 cURL Examples

```bash
# Enviar email com template
curl -X POST http://localhost:8000/api/emails/send \
  -H "Content-Type: application/json" \
  -d '{
    "to_email": "usuario@example.com",
    "subject": "Verifica√ß√£o de Email",
    "template_name": "verification",
    "template_vars": {
      "token": "12345",
      "protocol": "INTC-2025-001"
    },
    "priority": "urgent"
  }'

# Consultar status
curl http://localhost:8000/api/emails/status/{email_id}

# Estat√≠sticas
curl http://localhost:8000/api/emails/stats
```

### 20.3 Integra√ß√£o com Backend Node.js Existente

```typescript
// INTELLICAREREPO/backend/src/lib/emailService.ts
import axios from 'axios';

const EMAIL_SERVICE_URL = process.env.EMAIL_SERVICE_URL || 'http://localhost:8000';

export async function sendVerificationEmail(
  email: string,
  token: string,
  protocol: string
): Promise<{ taskId: string; emailId: string }> {
  const response = await axios.post(`${EMAIL_SERVICE_URL}/api/emails/send`, {
    to_email: email,
    subject: 'IntelliCare - Verifica√ß√£o de Email',
    template_name: 'verification',
    template_vars: { token, protocol },
    priority: 'urgent',
  });

  return {
    taskId: response.data.task_id,
    emailId: response.data.email_id,
  };
}

export async function sendStatusUpdateEmail(
  email: string,
  protocol: string,
  status: string,
  message: string
): Promise<{ taskId: string; emailId: string }> {
  const response = await axios.post(`${EMAIL_SERVICE_URL}/api/emails/send`, {
    to_email: email,
    subject: `IntelliCare - Atualiza√ß√£o de Status: ${protocol}`,
    template_name: 'status_update',
    template_vars: { protocol, status, message },
    priority: 'normal',
  });

  return {
    taskId: response.data.task_id,
    emailId: response.data.email_id,
  };
}
```

---

## 21. MONITORING & OBSERVABILITY

### 21.1 Flower Dashboard

Acesse `http://localhost:5555` para:
- ‚úÖ Ver filas em tempo real
- ‚úÖ Monitorar workers ativos
- ‚úÖ Visualizar tarefas em execu√ß√£o
- ‚úÖ Hist√≥rico de tarefas
- ‚úÖ Taxa de sucesso/falha

### 21.2 Logs Estruturados

```python
# Todos os logs incluem:
{
  "timestamp": "2025-02-03T18:00:00Z",
  "level": "INFO",
  "service": "email_service",
  "email_id": "uuid-here",
  "to_email": "user@example.com",
  "status": "sent",
  "provider": "SMTP",
  "attempts": 1,
  "duration_ms": 1234
}
```

### 21.3 M√©tricas Prometheus (futuro)

```python
# Adicionar ao main.py
from prometheus_fastapi_instrumentator import Instrumentator

Instrumentator().instrument(app).expose(app)
```

---

## 22. TROUBLESHOOTING

### Problema: Emails n√£o est√£o sendo enviados

**Solu√ß√£o:**
```bash
# 1. Verificar se Celery worker est√° rodando
celery -A email_service.celery_app inspect active

# 2. Verificar logs do worker
docker-compose logs -f celery_worker

# 3. Verificar fila Redis
redis-cli
> LLEN emails_urgent
> LLEN emails_normal
```

### Problema: SMTP Authentication Failed

**Solu√ß√£o:**
- Gmail: Usar "App Password" em vez de senha normal
- Verificar `SMTP_USE_TLS=true`
- Testar credenciais manualmente

### Problema: Tarefas ficam presas na fila

**Solu√ß√£o:**
```bash
# Limpar fila
celery -A email_service.celery_app purge

# Reiniciar workers
docker-compose restart celery_worker
```

---

## 23. NEXT STEPS & ROADMAP

### Fase 2 (Futuro)
- [ ] Webhooks para eventos (delivered, opened, clicked)
- [ ] Interface web de gerenciamento
- [ ] Editor WYSIWYG de templates
- [ ] A/B testing de emails
- [ ] Segmenta√ß√£o avan√ßada
- [ ] Relat√≥rios anal√≠ticos
- [ ] Suporte a Amazon SES
- [ ] Rate limiting por destinat√°rio
- [ ] Blacklist/whitelist de dom√≠nios
- [ ] Agendamento de campanhas

---

## 24. CONCLUS√ÉO

Este sistema fornece uma **solu√ß√£o completa, robusta e profissional** para gerenciamento de emails em Python, com:

‚úÖ **Arquitetura ass√≠ncrona** (FastAPI + Celery)
‚úÖ **Alta disponibilidade** (retry autom√°tico, fallback)
‚úÖ **Escalabilidade** (workers horizontais, filas por prioridade)
‚úÖ **Observabilidade** (logs, m√©tricas, Flower)
‚úÖ **Flexibilidade** (m√∫ltiplos provedores, templates)
‚úÖ **Produ√ß√£o-ready** (Docker, Kubernetes, testes)

**Tempo estimado de implementa√ß√£o:** 8 dias
**Manuten√ß√£o:** Baixa (sistema auto-gerenciado)
**Custo:** Opensource (apenas infraestrutura)

---

**Documenta√ß√£o completa!** üéâ

Para come√ßar a implementa√ß√£o, siga o guia de deployment na se√ß√£o 18.

